/**
 * @file FileLocation.cpp
 *
 * Implements the file location class.
 */

#include "stdafx.h"
#include <sstream>
#include <memory>
#include "FileLocation.h"

#pragma comment (lib, "Shlwapi.lib")

/**
 * A structure used to map enum values to file names.
 */

struct stIniEnumToFilenameMap
{
    /**
     * The identifier.
     */

    CFileLocation::FilesEnum id;

    /**
     * The name.
     */

    std::string name;
};

/**
 * A map of ini file enum values to file names.
 */

struct stIniEnumToFilenameMap IniNameMap[] =
{
    {CFileLocation::GUILDLL_INI_FILE,  "Guidll.ini"},
    {CFileLocation::HARDWARE_INI_FILE, "Hardware.ini"},
    {CFileLocation::RUNTIME_INI_FILE,  "RunTime.ini"},
    {CFileLocation::CONFIG_INI_FILE,   "Config.ini"},
};

/**
 * A map of log file enum values to file names.
 */

struct stIniEnumToFilenameMap LogNameMap[] =
{
    {CFileLocation::DEBUG_LOG,        "Dbg.log"},
    {CFileLocation::DEBUG_TIMING_LOG, "DbgTiming.log"},
    {CFileLocation::GUIEVENT_LOG,     "GUIEventLog.log"},
};

struct stIniEnumToFilenameMap DataBaseMap[] =
{
    {CFileLocation::MACHINE_DB_FILE,  "MitMc.mdb"},
    {CFileLocation::JAM_DB_FILE,      "MitJamInfoDB.mdb"},
    {CFileLocation::PACKAGE_DB_FILE,  "MitPkg.mdb"},
    {CFileLocation::LOTINFO_DB_FILE,  "MitLot.mdb"},
    {CFileLocation::LANGUAGE_DB_FILE, "MitLanguage.mdb"},
    {CFileLocation::MESSAGE_DB_FILE,  "MitMessages.mdb"},
};

/**
 * The root folder for ini files.
 */

static const std::string DEFAULT_INI_ROOT("D:\\Machine\\Ini");

/**
 * The root folder for log files.
 */

static const std::string DEFAULT_LOG_ROOT("D:\\Machine\\DebugLog");

/*
 * The root for the database files
 */
static const std::string DEFAULT_DB_ROOT("D:\\Machine\\Database");

/**
 * @class CFileLocation
 *        The file location class is meant to be a central place to define and manipulate locations of standard files.
 *        The locations can be changed during unit testing and reset after testing is completed. This allows the user
 *        to manipulate behaviour of objects by changing the ini files and examine log files generated by the objects
 *        during testing.
 */

/**
 * Default constructor. Loads the default locations of all files.
 */

CFileLocation::CFileLocation(void)
{
    LoadLocations();
}

/**
 * Destructor.
 */

CFileLocation::~CFileLocation(void)
{
}

/**
 * Resets this object. Reloads all default locations of the files.
 */

void CFileLocation::Reset()
{
    LoadLocations();
}

/**
 * Loads the locations.
 */

void CFileLocation::LoadLocations()
{
    for each (auto e in IniNameMap)
    {
        m_strFilePath[e.id] = BuildPath(DEFAULT_INI_ROOT, e.name);
    }

    for each (auto e in LogNameMap)
    {
        m_strFilePath[e.id] = BuildPath(DEFAULT_LOG_ROOT, e.name);
    }

    for each (auto e in DataBaseMap)
    {
        m_strFilePath[e.id] = BuildPath(DEFAULT_DB_ROOT, e.name);
    }
}

/**
 * Updates the full path of a specific file.
 *
 * @param f    The enum value representing the file whose location needs to change.
 * @param path Full pathname of the file.
 */

void CFileLocation::UpdatePath(FilesEnum f, const std::string &path)
{
    m_strFilePath[f] = path;
}

/**
 * Gets the instance.
 *
 * @return A CFileLocation&amp;
 */

CFileLocation &CFileLocation::instance()
{
    static CFileLocation instance;
    return instance;
}

/**
 * Gets a location.
 *
 * @param f The enum value representing the file whose location needs to change.
 *
 * @return null if it fails, else the location.
 */

const char *CFileLocation::GetLocation(FilesEnum f)
{
    return m_strFilePath[f].c_str();
}

/**
 * Gets current directory were the application runs.
 *
 * @return The current directory.
 */

std::string CFileLocation::GetCurrentDirectory()
{
    char cDir[_MAX_PATH];
    ::GetCurrentDirectory(_MAX_PATH, cDir);
    return cDir;
}

/**
 * Builds a path.
 *
 * Combines the path with a sub path. Is commonly used to define a new file location.
 *
 * @code{.cpp}
 * auto fileLocation = CFileLocation::BuildPath(CFileLocation::GetCurrentDirectory(), "test.log));
 * CFileLocation::instance().UpdatePath(CFileLocation::DEBUG_LOG, fileLocation);
 * @endcode.
 *
 * @param path    Full pathname of the file.
 * @param subPath Full pathname of the sub file.
 *
 * @return A std::string.
 */

std::string CFileLocation::BuildPath(const std::string &path, const std::string &subPath)
{
    std::ostringstream stringStream;
    stringStream << path << "\\" << subPath;
    return stringStream.str();
}

/**
 * Gets sub path in current directory. Adds a sub path to the current directory. This is
 * commonly used to create a file spec that is a sub path of the current directory.
 *
 * @code{.cpp}
 * auto fileLocation = CFileLocation::GetSubPathInCurrentDirectory("test.log));
 * CFileLocation::instance().UpdatePath(CFileLocation::DEBUG_LOG, fileLocation);
 * @endcode.
 *
 * @param subPath Full pathname of the sub file.
 *
 * @return The sub path in current directory.
 */

std::string CFileLocation::GetSubPathInCurrentDirectory(const std::string &subPath)
{
    return BuildPath(GetCurrentDirectory(), subPath);
}

/**
 * Gets file version.
 *
 * @param filename Filename of the file.
 *
 * @return The file version.
 */

std::string CFileLocation::GetFileVersion(const std::string &filename)
{
    DWORD   dwHandle;
    DWORD   dwSize        = GetFileVersionInfoSize(filename.c_str(), &dwHandle);
    CString csFileVersion = _T("");

    if (dwSize)
    {
        std::unique_ptr<BYTE> pAbyInfo(new BYTE[dwSize]);
        BOOL                  bResult = GetFileVersionInfo(filename.c_str(), 0, dwSize, pAbyInfo.get());
        if (bResult)
        {
            UINT   uSize;
            LPVOID pInfo;
            bResult = VerQueryValue(pAbyInfo.get(), TEXT("\\StringFileInfo\\040904b0\\FileVersion"), &pInfo, &uSize);
            if (bResult)
            {
                const char* pVersionInfo = static_cast<char*>(pInfo);
                return std::string(pVersionInfo);
            }
        }
    }

    return "";
}

/**
 * Gets current module path.
 *
 * Find the full path of the current executable running.
 *
 * @return The current module path.
 */

std::string CFileLocation::GetCurrentModulePath()
{
    HMODULE hModule = GetModuleHandle(NULL);
    char    modulePath[_MAX_PATH];
    if (GetModuleFileName(hModule, modulePath, (sizeof(modulePath))))
    {
        return modulePath;
    }

    return "";
}

/**
 * Path remove file specifier.
 *
 * Removes the filename from the full path.
 *
 * @param filename Filename of the file.
 *
 * @return the directory path of the filename
 */

std::string CFileLocation::PathRemoveFileSpec(const std::string &filename)
{
    char path[_MAX_PATH];
    strncpy(path, filename.c_str(), _MAX_PATH);
    ::PathRemoveFileSpec(path);
    return path;
}

/**
 * Strips the path from the full path name and return the filename
 *
 * @param filename The full path
 *
 * @return the filename
 */

std::string CFileLocation::PathStripPath(const std::string &filename)
{
    char path[_MAX_PATH];
    strncpy(path, filename.c_str(), _MAX_PATH);
    ::PathStripPath(path);
    return path;
}

bool CFileLocation::Exists(const std::string &path)
{
    return PathFileExists(path.c_str()) == TRUE;
}
